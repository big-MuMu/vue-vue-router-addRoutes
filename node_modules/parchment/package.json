{
  "_args": [
    [
      {
        "raw": "parchment@1.1.0",
        "scope": null,
        "escapedName": "parchment",
        "name": "parchment",
        "rawSpec": "1.1.0",
        "spec": "1.1.0",
        "type": "version"
      },
      "/Users/zhangsen/zhangsen/Train/trainPC/node_modules/quill"
    ]
  ],
  "_from": "parchment@1.1.0",
  "_id": "parchment@1.1.0",
  "_inCache": true,
  "_location": "/parchment",
  "_nodeVersion": "7.7.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/parchment-1.1.0.tgz_1497999780423_0.6249511553905904"
  },
  "_npmUser": {
    "name": "jhchen",
    "email": "jhchen7@gmail.com"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "parchment@1.1.0",
    "scope": null,
    "escapedName": "parchment",
    "name": "parchment",
    "rawSpec": "1.1.0",
    "spec": "1.1.0",
    "type": "version"
  },
  "_requiredBy": [
    "/quill"
  ],
  "_resolved": "https://registry.npmjs.org/parchment/-/parchment-1.1.0.tgz",
  "_shasum": "c79387a80fc4af4ba8947b94fc55a835f62850a5",
  "_shrinkwrap": null,
  "_spec": "parchment@1.1.0",
  "_where": "/Users/zhangsen/zhangsen/Train/trainPC/node_modules/quill",
  "author": {
    "name": "Jason Chen",
    "email": "jhchen7@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/quilljs/parchment/issues"
  },
  "dependencies": {},
  "description": "A document model for rich text editors",
  "devDependencies": {
    "istanbul": "~0.4.5",
    "jasmine-core": "^2.6.4",
    "karma": "^1.7.0",
    "karma-babel-preprocessor": "^6.0.1",
    "karma-chrome-launcher": "^2.1.1",
    "karma-coverage": "^1.1.1",
    "karma-jasmine": "^1.1.0",
    "karma-sauce-launcher": "^1.1.0",
    "karma-webpack": "^2.0.3",
    "ts-loader": "^2.1.0",
    "typescript": "^2.3.4",
    "webpack": "^3.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "c79387a80fc4af4ba8947b94fc55a835f62850a5",
    "tarball": "https://registry.npmjs.org/parchment/-/parchment-1.1.0.tgz"
  },
  "engines": {
    "node": ">= 5.3",
    "npm": ">= 3.5"
  },
  "files": [
    "tsconfig.json",
    "dist",
    "src"
  ],
  "gitHead": "54413c811b2faccf528003d377ce4f35e3a7e218",
  "homepage": "http://quilljs.com/docs/parchment",
  "license": "BSD-3-Clause",
  "main": "dist/parchment.js",
  "maintainers": [
    {
      "name": "jhchen",
      "email": "jhchen7@gmail.com"
    }
  ],
  "name": "parchment",
  "optionalDependencies": {},
  "readme": "# Parchment [![Build Status](https://travis-ci.org/quilljs/parchment.svg?branch=master)](http://travis-ci.org/quilljs/parchment) [![Coverage Status](https://coveralls.io/repos/github/quilljs/parchment/badge.svg?branch=master)](https://coveralls.io/github/quilljs/parchment?branch=master)\n\nParchment is [Quill](https://quilljs.com)'s document model. It is a parallel tree structure to the DOM tree, and provides functionality useful for content editors, like Quill. A Parchment tree is made up of [Blots](#blots), which mirror a DOM node counterpart. Blots can provide structure, formatting, and/or content. [Attributors](#attributors) can also provide lightweight formatting information.\n\n**Note:** You should never instantiate a Blot yourself with `new`. This may prevent necessary lifecycle functionality of a Blot. Use the [Registry](#registry)'s `create()` method instead.\n\n`npm install --save parchment`\n\nSee [Cloning Medium with Parchment](https://quilljs.com/guides/cloning-medium-with-parchment/) for a guide on how Quill uses Parchment its document model.\n\n## Blots\n\nBlots are the basic building blocks of a Parchment document. Several basic implementations such as [Block](#block-blot), [Inline](#inline-blot), and [Embed](#embed-blot) are provided. In general you will want to extend one of these, instead of building from scratch. After implementation, blots need to be [registered](#registry) before usage.\n\nAt the very minimum a Blot must be named with a static `blotName` and associated with either a `tagName` or `className`. If a Blot is defined with both a tag and class, the class takes precedence, but the tag may be used as a fallback. Blots must also have a [scope](#registry), which determine if it is inline or block.\n\n```typescript\nclass Blot {\n  static blotName: string;\n  static className: string;\n  static tagName: string;\n  static scope: Scope;\n\n  domNode: Node;\n  prev: Blot;\n  next: Blot;\n  parent: Blot;\n\n  // Creates corresponding DOM node\n  static create(value?: any): Node;\n\n  constructor(domNode: Node, value?: any);\n\n  // For leaves, length of blot's value()\n  // For parents, sum of children's values\n  length(): Number;\n\n  // Manipulate at given index and length, if applicable.\n  // Will often pass call onto appropriate child.\n  deleteAt(index: number, length: number);\n  formatAt(index: number, length: number, format: string, value: any);\n  insertAt(index: number, text: string);\n  insertAt(index: number, embed: string, value: any);\n\n  // Returns offset between this blot and an ancestor's\n  offset(ancestor: Blot = this.parent): number;\n\n  // Called after update cycle completes. Cannot change the value or length\n  // of the document, and any DOM operation must reduce complexity of the DOM\n  // tree. A shared context object is passed through all blots.\n  optimize(context: {[key: string]: any}): void;\n\n  // Called when blot changes, with the mutation records of its change.\n  // Internal records of the blot values can be updated, and modifcations of\n  // the blot itself is permitted. Can be trigger from user change or API call.\n  // A shared context object is passed through all blots.\n  update(mutations: MutationRecord[], context: {[key: string]: any});\n\n\n  /** Leaf Blots only **/\n\n  // Returns the value represented by domNode if it is this Blot's type\n  // No checking that domNode can represent this Blot type is required so\n  // applications needing it should check externally before calling.\n  static value(domNode): any;\n\n  // Given location represented by node and offset from DOM Selection Range,\n  // return index to that location.\n  index(node: Node, offset: number): number;\n\n  // Given index to location within blot, return node and offset representing\n  // that location, consumable by DOM Selection Range\n  position(index: number, inclusive: boolean): [Node, number];\n\n  // Return value represented by this blot\n  // Should not change without interaction from API or\n  // user change detectable by update()\n  value(): any;\n\n\n  /** Parent blots only **/\n\n  // Whitelist array of Blots that can be direct children.\n  static allowedChildren: Blot[];\n\n  // Default child blot to be inserted if this blot becomes empty.\n  static defaultChild: string;\n\n  children: LinkedList<Blot>;\n\n  // Called during construction, should fill its own children LinkedList.\n  build();\n\n  // Useful search functions for descendant(s), should not modify\n  descendant(type: BlotClass, index: number, inclusive): Blot\n  descendents(type: BlotClass, index: number, length: number): Blot[];\n\n\n  /** Formattable blots only **/\n\n  // Returns format values represented by domNode if it is this Blot's type\n  // No checking that domNode is this Blot's type is required.\n  static formats(domNode: Node);\n\n  // Apply format to blot. Should not pass onto child or other blot.\n  format(format: name, value: any);\n\n  // Return formats represented by blot, including from Attributors.\n  formats(): Object;\n}\n```\n\n### Example\n\nImplementation for a Blot representing a link, which is a parent, inline scoped, and formattable.\n\n```typescript\nimport Parchment from 'parchment';\n\nclass LinkBlot extends Parchment.Inline {\n  static create(url) {\n    let node = super.create();\n    node.setAttribute('href', url);\n    node.setAttribute('target', '_blank');\n    node.setAttribute('title', node.textContent);\n    return node;\n  }\n\n  static formats(domNode) {\n    return domNode.getAttribute('href') || true;\n  }\n\n  format(name, value) {\n    if (name === 'link' && value) {\n      this.domNode.setAttribute('href');\n    } else {\n      super.format(name, value);\n    }\n  }\n\n  formats() {\n    let formats = super.formats();\n    formats['link'] = LinkBlot.formats(this.domNode);\n    return formats;\n  }\n}\nLinkBlot.blotName = 'link';\nLinkBlot.tagName = 'A';\n\nParchment.register(LinkBlot);\n```\n\nQuill also provides many great example implementions in its [source code](https://github.com/quilljs/quill/tree/develop/formats).\n\n### Block Blot\n\nBasic implementation of a block scoped formattable parent Blot. Formatting a block blot by default will replace the appropriate subsection of the blot.\n\n### Inline Blot\n\nBasic implementation of an inline scoped formattable parent Blot. Formatting an inline blot by default either wraps itself with another blot or passes the call to the approprate child.\n\n### Embed Blot\n\nBasic implementation of a non-text leaf blot, that is formattable. Its corresponding DOM node will often be a [Void Element](https://www.w3.org/TR/html5/syntax.html#void-elements), but can be a [Normal Element](https://www.w3.org/TR/html5/syntax.html#normal-elements). In these cases Parchment will not manipulate or generally be aware of the element's children, and it will be important to correctly implement the blot's `index()` and `position()` functions to correctly work with cursors/selections.\n\n### Scroll\n\nThe root parent blot of a Parchment document. It is not formattable.\n\n\n## Attributors\n\nAttributors are the alternative, more lightweight, way to represent formats. Their DOM counterpart is an [Attribute](https://www.w3.org/TR/html5/syntax.html#attributes-0). Like a DOM attribute's relationship to a node, Attributors are meant to belong to Blots. Calling `formats()` on an [Inline](#inline-blot) or [Block](#block-blot) blot will return both the format of the corresponding DOM node represents (if any) and the formats the DOM node's attributes represent (if any).\n\nAttributors have the following interface:\n\n```typescript\nclass Attributor {\n  attrName: string;\n  keyName: string;\n  scope: Scope;\n  whitelist: string[];\n\n  constructor(attrName: string, keyName: string, options: Object = {});\n  add(node: HTMLElement, value: string): boolean;\n  canAdd(node: HTMLElement, value: string): boolean;\n  remove(node: HTMLElement);\n  value(node: HTMLElement);\n}\n```\n\nNote custom attributors are instances, rather than class definitions like Blots. Similar to Blots, instead of creating from scratch, you will probably want to use existing Attributor implementations, such as the base [Attributor](#attributor), [Class Attributor](#class-attributor) or [Style Attributor](#style-attributor).\n\nThe implementation for Attributors is surprisingly simple, and its [source code](https://github.com/quilljs/parchment/tree/master/src/attributor) may be another source of understanding.\n\n### Attributor\n\nUses a plain attribute to represent formats.\n\n```js\nimport Parchment from 'parchment';\n\nlet Width = new Parchment.Attributor.Attribute('width', 'width');\nParchment.register(Width);\n\nlet imageNode = document.createElement('img');\n\nWidth.add(imageNode, '10px');\nconsole.log(imageNode.outerHTML);   // Will print <img width=\"10px\">\nWidth.value(imageNode);\t                // Will return 10px\nWidth.remove(imageNode);\nconsole.log(imageNode.outerHTML);   // Will print <img>\n```\n\n### Class Attributor\n\nUses a classname pattern to represent formats.\n\n```js\nimport Parchment from 'parchment';\n\nlet Align = new Parchment.Attributor.Class('align', 'blot-align');\nParchment.register(Align);\n\nlet node = document.createElement('div');\nAlign.add(node, 'right');\nconsole.log(node.outerHTML);  // Will print <div class=\"blot-align-right\"></div>\n```\n\n### Style Attributor\n\nUses inline styles to represent formats.\n\n```js\nimport Parchment from 'parchment';\n\nlet Align = new Parchment.Attributor.Style('align', 'text-align', {\n  whitelist: ['right', 'center', 'justify']   // Having no value implies left align\n});\nParchment.register(Align);\n\nlet node = document.createElement('div');\nAlign.add(node, 'right');\nconsole.log(node.outerHTML);  // Will print <div style=\"text-align: right;\"></div>\n```\n\n## Registry\n\nAll methods are accessible from Parchment ex. `Parchment.create('bold')`.\n\n```typescript\n// Creates a blot given a name or DOM node.\n// When given just a scope, creates blot the same name as scope\ncreate(domNode: Node, value?: any): Blot;\ncreate(blotName: string, value?: any): Blot;\ncreate(scope: Scope): Blot;\n\n// Given DOM node, find corresponding Blot.\n// Bubbling is useful when searching for a Embed Blot with its corresponding\n// DOM node's descendant nodes.\nfind(domNode: Node, bubble: boolean = false): Blot;\n\n// Search for a Blot or Attributor\n// When given just a scope, finds blot with same name as scope\nquery(tagName: string, scope: Scope = Scope.ANY): BlotClass;\nquery(blotName: string, scope: Scope = Scope.ANY): BlotClass;\nquery(domNode: Node, scope: Scope = Scope.ANY): BlotClass;\nquery(scope: Scope): BlotClass;\nquery(attributorName: string, scope: Scope = Scope.ANY): Attributor;\n\n// Register Blot class definition or Attributor instance\nregister(BlotClass | Attributor);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/quilljs/parchment.git"
  },
  "scripts": {
    "build": "webpack --config webpack.conf.js",
    "prepublish": "npm run build",
    "test": "karma start",
    "test:server": "karma start --no-single-run",
    "test:travis": "karma start --browsers saucelabs-chrome --reporters dots,saucelabs"
  },
  "types": "dist/src/parchment.d.ts",
  "version": "1.1.0"
}
